use crate::arb::global::constant::duration::Interval;
use crate::arb::pipeline::event_processor::token_balance::processor::{
    TokenAmount, TokenBalanceShortLivingCache,
};
use crate::arb::util::alias::MintAddress;
use crate::arb::util::structs::ttl_loading_cache::TtlLoadingCache;
use once_cell::sync::Lazy;
use solana_program::pubkey::Pubkey;

#[allow(non_upper_case_globals)]
pub static LongTermCache: Lazy<TtlLoadingCache<(Pubkey, MintAddress), TokenAmount>> =
    Lazy::new(|| TtlLoadingCache::new(20_000_000, Interval::WEEK, |_| async move { None }));

pub async fn get_balance_of_account(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    let key = &(account.clone(), mint.clone());
    // first, fetch from short term cache which is generated by grpc streaming
    let short_living = TokenBalanceShortLivingCache.get(key).await;
    if let Some(amount) = short_living {
        // if found, update long living cache, put to long live, then return
        LongTermCache.put(*key, amount.clone()).await;
        return Some(amount);
    }
    // found from long live
    LongTermCache.get(key).await
}
