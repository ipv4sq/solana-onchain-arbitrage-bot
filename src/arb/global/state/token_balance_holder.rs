use crate::arb::database::mint_record::repository::MintRecordRepository;
use crate::arb::global::client::rpc::rpc_client;
use crate::arb::global::constant::duration::Interval;
use crate::arb::pipeline::event_processor::token_balance::token_balance_processor::{
    TokenAmount, TokenBalanceShortLivingCache,
};
use crate::arb::util::alias::MintAddress;
use crate::arb::util::structs::rate_limiter::RateLimiter;
use crate::arb::util::structs::ttl_loading_cache::TtlLoadingCache;
use crate::lazy_arc;
use once_cell::sync::Lazy;
use solana_program::program_pack::Pack;
use solana_program::pubkey::Pubkey;
use spl_token::state::Account;
use std::sync::Arc;
use std::time::Duration;
use tracing::{error, warn};

#[allow(non_upper_case_globals)]
static LongTermCache: Lazy<TtlLoadingCache<(Pubkey, MintAddress), TokenAmount>> =
    Lazy::new(|| TtlLoadingCache::new(20_000_000, Interval::WEEK, |_| async move { None }));

#[allow(non_upper_case_globals)]
pub static QueryRateLimiter: Lazy<Arc<RateLimiter>> = lazy_arc!({
    RateLimiter::new(
        25,
        Duration::from_secs(1),
        30,
        "AccountBalanceQueryRateLimiter".to_string(),
    )
});

pub async fn get_balance_of_account(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    let key = &(account.clone(), mint.clone());

    // first, fetch from short term cache which is generated by grpc streaming
    if let Some(amount) = TokenBalanceShortLivingCache.get(key).await {
        // if found, update long living cache, put to long live, then return
        LongTermCache.put(*key, amount.clone()).await;
        return Some(amount);
    }

    // found from long live
    if let Some(amount) = LongTermCache.get(key).await {
        return Some(amount);
    }

    if let Some(amount) = fetch_from_rpc(account, mint).await {
        LongTermCache.put(key.clone(), amount.clone()).await;
        return Some(amount);
    }
    None
}

async fn fetch_from_rpc(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    if !QueryRateLimiter.try_acquire() {
        warn!("Query rate limiter expired.");
        return None;
    }
    let data = rpc_client().get_account(account).await.ok()?;
    let vault = Account::unpack_from_slice(&data.data).ok()?;
    if *mint != vault.mint {
        error!("Fucked up here mint={:?}, vault={:?}", mint, vault);
    }
    let decimals = MintRecordRepository::get_decimal(mint).await.ok()??;
    Some(TokenAmount {
        amount: vault.amount,
        decimals,
    })
}
