use crate::database::mint_record::repository::MintRecordRepository;
use crate::lazy_arc;
use crate::pipeline::event_processor::token_balance::token_balance_processor::{
    TokenAmount, TokenBalanceShortLivingCache,
};
use crate::sdk::rpc::methods::account::buffered_get_account;
use crate::util::alias::MintAddress;
use crate::util::cache::loading_cache::LoadingCache;
use crate::util::structs::rate_limiter::RateLimiter;
use once_cell::sync::Lazy;
use solana_program::program_pack::Pack;
use solana_program::pubkey::Pubkey;
use spl_token::state::Account;
use spl_token_2022::extension::StateWithExtensions;
use std::sync::Arc;
use std::time::Duration;
use tracing::{error, warn};

type Token2022Account<'a> = StateWithExtensions<'a, spl_token_2022::state::Account>;

#[allow(non_upper_case_globals)]
static LongTermCache: Lazy<LoadingCache<(Pubkey, MintAddress), TokenAmount>> = Lazy::new(|| {
    LoadingCache::with_ttl(
        1_000_000,
        Duration::from_secs(3600 * 3),
        |_| async move { None },
    )
});

#[allow(non_upper_case_globals)]
pub static QueryRateLimiter: Lazy<Arc<RateLimiter>> = lazy_arc!({
    RateLimiter::new(
        60,
        Duration::from_secs(1),
        70,
        "AccountBalanceQueryRateLimiter".to_string(),
    )
});

pub async fn get_balance_of_account(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    let key = &(account.clone(), mint.clone());

    // first, fetch from short term cache which is generated by grpc streaming
    if let Some(amount) = TokenBalanceShortLivingCache.get(key).await {
        // if found, update long living cache, put to long live, then return
        LongTermCache.put(*key, amount.clone()).await;
        return Some(amount);
    }

    // found from long live
    if let Some(amount) = LongTermCache.get(key).await {
        return Some(amount);
    }

    if let Some(amount) = fetch_from_rpc(account, mint).await {
        LongTermCache.put(key.clone(), amount.clone()).await;
        return Some(amount);
    }
    None
}

async fn fetch_from_rpc(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    if let Err(e) = QueryRateLimiter.try_acquire_err() {
        warn!("Query rate limiter expired: {}", e);
        return None;
    }
    let data = buffered_get_account(account).await.ok()?;

    let (vault_mint, vault_amount) = if let Ok(vault) = Account::unpack_from_slice(&data.data) {
        (vault.mint, vault.amount)
    } else if let Ok(state) = Token2022Account::unpack(&data.data) {
        (state.base.mint, state.base.amount)
    } else {
        return None;
    };

    if *mint != vault_mint {
        error!(
            "Fucked up here mint={:?}, vault_mint={:?}",
            mint, vault_mint
        );
    }
    let decimals = MintRecordRepository::get_decimal(mint).await?;
    Some(TokenAmount {
        amount: vault_amount,
        decimals,
    })
}
