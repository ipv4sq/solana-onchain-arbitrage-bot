use crate::database::mint_record::repository::MintRecordRepository;
use crate::pipeline::event_processor::token_balance::token_balance_processor::{
    TokenAmount, TokenBalanceShortLivingCache,
};
use crate::sdk::solana_rpc::buffered_get_account::buffered_get_account;
use crate::sdk::solana_rpc::rpc::rpc_client;
use crate::util::alias::MintAddress;
use crate::util::structs::rate_limiter::RateLimiter;
use crate::util::structs::ttl_loading_cache::TtlLoadingCache;
use crate::lazy_arc;
use once_cell::sync::Lazy;
use solana_program::program_pack::Pack;
use solana_program::pubkey::Pubkey;
use spl_token::state::Account;
use std::sync::Arc;
use std::time::Duration;
use tracing::{error, warn};

#[allow(non_upper_case_globals)]
static LongTermCache: Lazy<TtlLoadingCache<(Pubkey, MintAddress), TokenAmount>> = Lazy::new(|| {
    TtlLoadingCache::new(
        1_000_000,
        Duration::from_secs(3600 * 3),
        |_| async move { None },
    )
});

#[allow(non_upper_case_globals)]
pub static QueryRateLimiter: Lazy<Arc<RateLimiter>> = lazy_arc!({
    RateLimiter::new(
        60,
        Duration::from_secs(1),
        70,
        "AccountBalanceQueryRateLimiter".to_string(),
    )
});

pub async fn get_balance_of_account(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    let key = &(account.clone(), mint.clone());

    // first, fetch from short term cache which is generated by grpc streaming
    if let Some(amount) = TokenBalanceShortLivingCache.get(key).await {
        // if found, update long living cache, put to long live, then return
        LongTermCache.put(*key, amount.clone()).await;
        return Some(amount);
    }

    // found from long live
    if let Some(amount) = LongTermCache.get(key).await {
        return Some(amount);
    }

    if let Some(amount) = fetch_from_rpc(account, mint).await {
        LongTermCache.put(key.clone(), amount.clone()).await;
        return Some(amount);
    }
    None
}

async fn fetch_from_rpc(account: &Pubkey, mint: &MintAddress) -> Option<TokenAmount> {
    if let Err(e) = QueryRateLimiter.try_acquire_err() {
        warn!("Query rate limiter expired: {}", e);
        return None;
    }
    let data = buffered_get_account(account).await.ok()?;
    let vault = Account::unpack_from_slice(&data.data).ok()?;
    if *mint != vault.mint {
        error!("Fucked up here mint={:?}, vault={:?}", mint, vault);
    }
    let decimals = MintRecordRepository::get_decimal(mint).await?;
    Some(TokenAmount {
        amount: vault.amount,
        decimals,
    })
}
